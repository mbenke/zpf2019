<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marcin Benke" />
  <title>Zaawansowane programowanie funkcyjne</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Zaawansowane programowanie funkcyjne</h1>
  <p class="author">
Marcin Benke
  </p>
  <p class="date">27 lutego 2018</p>
</div>
<div class="slide section level1">

<meta name="duration" content="80" />
</div>
<div id="plan-wykładu" class="slide section level1">
<h1>Plan wykładu</h1>
<ul>
<li>Typy i klasy
<ul>
<li>Typy algebraiczne i klasy typów</li>
<li>Klasy konstruktorowe</li>
<li>Klasy wieloparametrowe, zależności funkcyjne</li>
</ul></li>
<li>Testowanie (QuickCheck)</li>
<li>Typy zależne, Agda, Idris, Coq, dowodzenie własności (ok. 7 wykladów)</li>
<li>Typy zależne w Haskellu
<ul>
<li>Rodziny typów, typy skojarzone, uogólnione typy algebraiczne (GADT)</li>
<li>data kinds, kind polymorphism</li>
</ul></li>
<li>Metaprogramowanie</li>
<li>Programowanie równoległe i współbieżne w Haskellu
<ul>
<li>Programowanie wielordzeniowe i wieloprocesorowe (SMP)</li>
<li>Równoległość danych (Data Parallel Haskell)</li>
</ul></li>
<li>Prezentacje projektów</li>
</ul>
<p>Jakieś życzenia?</p>
</div>
<div id="zasady-zaliczania" class="slide section level1">
<h1>Zasady zaliczania</h1>
<ul>
<li>Laboratorium: zdefiniowane zadanie Coq + <strong>prosty</strong> projekt 1-3 osobowy - Haskell</li>
<li>Egzamin ustny, którego istotną częścią jest prezentacja projektu.</li>
<li>Alternatywna forma zaliczenia: referat (koniecznie ciekawy!)</li>
<li>…możliwe także inne formy.</li>
</ul>
</div>
<div id="materiały" class="slide section level1">
<h1>Materiały</h1>
<pre><code>$ cabal update
$ cabal install pandoc
$ PATH=~/.cabal/bin:$PATH            # Linux
$ PATH=~/Library/Haskell/bin:$PATH   # OS X
$ git clone git://github.com/mbenke/zpf2018.git
$ cd zpf2018/Slides
$ make</code></pre>
<p>albo, przy użyciu stack - https://haskellstack.org/</p>
<pre><code>stack setup
stack install pandoc
export PATH=$(stack path --local-bin):$PATH
...</code></pre>
<p>Na students można jak wyżej albo jeśli brakuje quota, z użyciem systemowego GHC:</p>
<pre><code>export PATH=/home/students/inf/PUBLIC/MRJP/ghc-8.2.2/bin:$PATH
export STACK=&quot;/home/students/inf/PUBLIC/MRJP/Stack/stack --system-ghc --resolver ghc-8.2&quot;
$STACK setup
$STACK config set system-ghc true
$STACK  upgrade --force-download  # or cp stack executable to your path
#  ...
#  Should I try to perform the file copy using sudo? This may fail
#  Try using sudo? (y/n) n

export PATH=$($STACK path --local-bin):$PATH
stack install pandoc</code></pre>
</div>
<div id="dygresja---cabal-i-stack" class="slide section level1">
<h1>Dygresja - cabal i stack</h1>
<p><strong>Common Architecture for Building Applications and Libraries</strong></p>
<p><code>cabal install</code> - pozwala instalować biblioteki na swoim koncie, bez uprawnień administratora</p>
<pre><code>[ben@students Haskell]$ cabal update
Downloading the latest package list
  from hackage.haskell.org
[ben@students Haskell]$ cabal install GLFW
...kompilacja...
Installing library in
 /home/staff/iinf/ben/.cabal/lib/GLFW-0.4.2/ghc-6.10.4
Registering GLFW-0.4.2...
Reading package info from &quot;dist/installed-pkg-config&quot;
 ... done.
Writing new package config file... done.</code></pre>
<p>Wiele bibliotek na <code>http://hackage.haskell.org/</code></p>
</div>
<div id="cabal-hell" class="slide section level1">
<h1>Cabal hell</h1>
<pre><code>$ cabal install criterion
Resolving dependencies...
In order, the following would be installed:
monad-par-extras-0.3.3 (reinstall) changes: mtl-2.1.2 -&gt; 2.2.1,
transformers-0.3.0.0 -&gt; 0.5.2.0
nats-1.1.1 (reinstall) changes: hashable-1.1.2.5 -&gt; 1.2.5.0
...
criterion-1.1.4.0 (new package)
cabal: The following packages are likely to be broken by the reinstalls:
monad-par-0.3.4.7
void-0.7.1
lens-4.15.1
...
HTTP-4000.3.3
Use --force-reinstalls if you want to install anyway.</code></pre>
<p>W nowszych wersjach cabal częściowo rozwiązane przez sandboxing i <code>cabal new-install</code> # Stack + stackage</p>
<blockquote>
<p>Stackage is a stable source of Haskell packages. We guarantee that packages build consistently and pass tests before generating nightly and Long Term Support (LTS) releases.</p>
</blockquote>
<pre><code>LTS 13.9 for GHC 8.6.3, published a day ago
LTS 12.26 for GHC 8.4.4, published a month ago
LTS 12.14 for GHC 8.4.3, published 4 months ago
LTS 11.22 for GHC 8.2.2, published 6 months ago
LTS 9.21 for GHC 8.0.2, published a year ago
LTS 7.24 for GHC 8.0.1, published a year ago
LTS 6.35 for GHC 7.10.3, published a year ago
LTS 3.22 for GHC 7.10.2, published 3 years ago
LTS 2.22 for GHC 7.8.4, published 4 years ago
LTS 0.7 for GHC 7.8.3, published 4 years ago</code></pre>
<pre><code>$ stack --resolver lts-3.22 install criterion
Run from outside a project, using implicit global project config
Using resolver: lts-3.22 specified on command line
Downloaded lts-3.22 build plan.
mtl-2.2.1: using precompiled package
...
criterion-1.1.0.0: download
criterion-1.1.0.0: configure
criterion-1.1.0.0: build
criterion-1.1.0.0: copy/register
</code></pre>
</div>
<div id="budowanie-projektu" class="slide section level1">
<h1>Budowanie projektu</h1>
<pre><code>$ stack new hello --resolver lts-11.22 &amp;&amp; cd hello
Downloading template &quot;new-template&quot; to create project &quot;hello&quot; in hello/ ...

Selected resolver: lts-11.22
Initialising configuration using resolver: lts-11.22
Total number of user packages considered: 1
Writing configuration to file: hello/stack.yaml
All done.

$ stack build
Building all executables for `hello&#39; once. After a successful build of all of th
em, only specified executables will be rebuilt.
hello-0.1.0.0: configure (lib + exe)
...
hello-0.1.0.0: copy/register
Installing library in /home/staff/iinf/ben/tmp/hello/.stack-work/install/x86_64-linux/lts-11.22/8.2.2/lib/x86_64-linux-ghc-8.2.2/hello-0.1.0.0-CaHXYhIIKYt3q9LDFmJN3m
Installing executable hello-exe in /home/staff/iinf/ben/tmp/hello/.stack-work/install/x86_64-linux/lts-11.22/8.2.2/bin
Registering library for hello-0.1.0.0..
$ stack exec hello-exe
someFunc</code></pre>
</div>
<div id="stack---ćwiczenia" class="slide section level1">
<h1>Stack - ćwiczenia</h1>
<ol style="list-style-type: decimal">
<li>Na własnym komputerze
<ul>
<li>Zainstalować <code>stack</code></li>
<li>Zainstalować GHC 7.10 przy pomocy <code>stack setup</code></li>
<li>Zainstalować GHC 8 przy pomocy <code>stack setup</code></li>
<li>Uruchomić <code>stack ghci</code> 7.10 i 8</li>
<li>Zbudować i uruchomić projekt hello, trochę go zmodyfikować</li>
</ul></li>
<li>Na students
<ul>
<li>Można zrobić to samo co powyżej, ale możliwy problem z quota</li>
<li><code>stack setup</code> przy użyciu GHC 8.2 (i może 7.10) z PUBLIC</li>
<li><code>stack config set system-ghc --global true</code></li>
<li>Reszta jak wyżej</li>
</ul></li>
</ol>
</div>
<div id="języki-funkcyjne" class="slide section level1">
<h1>Języki funkcyjne</h1>
<ul>
<li>typowane dynamicznie, gorliwe: Lisp</li>
<li>typowane statycznie, gorliwe, nieczyste: ML</li>
<li>typowane statycznie, leniwe, czyste: Haskell</li>
</ul>
<p>Ten wykład: Haskell, ze szczególnym naciskiem na typy.</p>
<p>Bogata struktura typów jest tym, co wyróżnia Haskell wśród innych języków.</p>
</div>
<div id="typy-jako-język-specyfikacji" class="slide section level1">
<h1>Typy jako język specyfikacji</h1>
<p>Typ funkcji często specyfikuje nie tylko jej wejście i wyjście ale i relacje między nimi:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">f ::</span> <span class="kw">forall</span> a<span class="fu">.</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb9-2" title="2">f x <span class="fu">=</span> <span class="fu">?</span></a></code></pre></div>
<p>Jeśli <code>(f x)</code> daje wynik, to musi nim być <code>x</code></p>
<ul>
<li><p>Philip Wadler “Theorems for Free”</p></li>
<li><p>Funkcja typu <code>a -&gt; IO b</code> może mieć efekty uboczne</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">import</span> <span class="dt">Data.IORef</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IORef</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb10-4" title="4">f i <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="fu">print</span> i</a>
<a class="sourceLine" id="cb10-6" title="6">  r <span class="ot">&lt;-</span> newIORef i</a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="fu">return</span> r</a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-10" title="10">  r <span class="ot">&lt;-</span> f <span class="dv">42</span></a>
<a class="sourceLine" id="cb10-11" title="11">  j <span class="ot">&lt;-</span> readIORef r</a>
<a class="sourceLine" id="cb10-12" title="12">  <span class="fu">print</span> j</a></code></pre></div></li>
</ul>
</div>
<div id="typy-jako-język-specyfikacji-2" class="slide section level1">
<h1>Typy jako język specyfikacji (2)</h1>
<p>Funkcja typu <code>Integer -&gt; Integer</code> zasadniczo nie może mieć efektów ubocznych</p>
<p>Liczby Fibonacciego w stałej pamięci</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="ot">fibST ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb11-4" title="4">fibST n <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="kw">if</span> n <span class="fu">&lt;</span> <span class="dv">2</span> <span class="kw">then</span> n <span class="kw">else</span> runST fib2 <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-6" title="6">      fib2 <span class="fu">=</span>  <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-7" title="7">        x <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb11-8" title="8">        y <span class="ot">&lt;-</span> newSTRef <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-9" title="9">        fib3 n x y</a>
<a class="sourceLine" id="cb11-10" title="10"></a>
<a class="sourceLine" id="cb11-11" title="11">      fib3 <span class="dv">0</span> x _ <span class="fu">=</span> readSTRef x</a>
<a class="sourceLine" id="cb11-12" title="12">      fib3 n x y <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-13" title="13">              x&#39; <span class="ot">&lt;-</span> readSTRef x</a>
<a class="sourceLine" id="cb11-14" title="14">              y&#39; <span class="ot">&lt;-</span> readSTRef y</a>
<a class="sourceLine" id="cb11-15" title="15">              writeSTRef x y&#39;</a>
<a class="sourceLine" id="cb11-16" title="16">              writeSTRef y (x&#39;<span class="fu">+</span>y&#39;)</a>
<a class="sourceLine" id="cb11-17" title="17">              fib3 (n<span class="fu">-</span><span class="dv">1</span>) x y</a></code></pre></div>
<p>Jak to?</p>
<pre><code>runST :: (forall s. ST s a) -&gt; a</code></pre>
<p>Typ <code>runST</code> gwarantuje, że efekty uboczne nie wyciekają. Funkcja <code>fibST</code> jest czysta.</p>
</div>
<div id="typy-jako-język-projektowania" class="slide section level1">
<h1>Typy jako język projektowania</h1>
<ul>
<li><p>Projektowanie programu przy użyciu typów i <code>undefined</code></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">conquer ::</span> [<span class="dt">Foo</span>] <span class="ot">-&gt;</span> [<span class="dt">Bar</span>]</a>
<a class="sourceLine" id="cb13-2" title="2">conquer fs <span class="fu">=</span> <span class="fu">concatMap</span> step fs</a>
<a class="sourceLine" id="cb13-3" title="3"></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="ot">step ::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> [<span class="dt">Bar</span>]</a>
<a class="sourceLine" id="cb13-5" title="5">step <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div></li>
</ul>
</div>
<div id="typy-jako-język-programowania" class="slide section level1">
<h1>Typy jako język programowania</h1>
<ul>
<li>Funkcje na typach obliczane w czasie kompilacji</li>
</ul>
<pre><code>~~~~ {.haskell}
data Zero
data Succ n

type One   = Succ Zero
type Two   = Succ One
type Three = Succ Two
type Four  = Succ Three

one   = undefined :: One
two   = undefined :: Two
three = undefined :: Three
four  = undefined :: Four

class Add a b c | a b -&gt; c where
  add :: a -&gt; b -&gt; c
  add = undefined
instance              Add  Zero    b  b
instance Add a b c =&gt; Add (Succ a) b (Succ c)
~~~~

~~~~
*Main&gt; :t add three one
add three one :: Succ (Succ (Succ (Succ Zero)))
~~~~</code></pre>
<ul>
<li>Ćwiczenie: rozszerzyć o mnożenie i silnię</li>
</ul>
</div>
<div id="typy-jako-język-programowania-2" class="slide section level1">
<h1>Typy jako język programowania (2)</h1>
<p>Wektory przy użyciu klas:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="dt">VNil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dt">Zero</span> a</a>
<a class="sourceLine" id="cb15-3" title="3"><span class="ot">  (:&gt;) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Succ</span> n) a</a>
<a class="sourceLine" id="cb15-4" title="4"></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="ot">vhead ::</span> <span class="dt">Vec</span> (<span class="dt">Succ</span> n) a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb15-6" title="6">vhead (x <span class="fu">:&gt;</span> xs) <span class="fu">=</span> x</a></code></pre></div>
<p><strong>Ćwiczenie:</strong> dopisać <code>vtail</code>, <code>vlast</code></p>
<p>Chcielibyśmy również mieć</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">vappend ::</span> <span class="dt">Add</span> m n s <span class="ot">=&gt;</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> s a</a></code></pre></div>
<p>ale tu niestety podstawowy system typów okazuje się za słaby - więcej wkrótce</p>
</div>
<div id="typy-jako-język-programowania-3" class="slide section level1">
<h1>Typy jako język programowania (3)</h1>
<ul>
<li><p>Wektory przy użyciu rodzin typów:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">data</span> <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="kw">data</span> <span class="dt">Suc</span> n <span class="fu">=</span> <span class="dt">Suc</span> n</a>
<a class="sourceLine" id="cb17-3" title="3"></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="kw">type</span> <span class="kw">family</span> m <span class="fu">:+</span> n</a>
<a class="sourceLine" id="cb17-5" title="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Zero</span> <span class="fu">:+</span> n <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb17-6" title="6"><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Suc</span> m) <span class="fu">:+</span> n <span class="fu">=</span> <span class="dt">Suc</span>(m<span class="fu">:+</span>n)</a>
<a class="sourceLine" id="cb17-7" title="7"></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-9" title="9">  <span class="dt">VNil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dt">Zero</span> a</a>
<a class="sourceLine" id="cb17-10" title="10"><span class="ot">  (:&gt;) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Suc</span> n) a</a>
<a class="sourceLine" id="cb17-11" title="11"></a>
<a class="sourceLine" id="cb17-12" title="12"><span class="ot">vhead ::</span> <span class="dt">Vec</span> (<span class="dt">Suc</span> n) a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb17-13" title="13"><span class="ot">vappend ::</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m<span class="fu">:+</span>n) a</a></code></pre></div></li>
</ul>
</div>
<div id="typy-zależne" class="slide section level1">
<h1>Typy zależne</h1>
<p>Prawdziwe programowanie na poziomie typów i dowodzenie własności programów możliwe w języku z typami zależnymi, takim jak Agda, Epigram, Idris</p>
<pre><code>module Data.Vec where
infixr 5 _∷_

data Vec (A : Set a) : ℕ → Set where
  []  : Vec A zero
  _∷_ : ∀ {n} (x : A) (xs : Vec A n) → Vec A (suc n)

_++_ : ∀ {a m n} {A : Set a} → Vec A m → Vec A n → Vec A (m + n)
[]       ++ ys = ys
(x ∷ xs) ++ ys = x ∷ (xs ++ ys)

module UsingVectorEquality {s₁ s₂} (S : Setoid s₁ s₂) where
  xs++[]=xs : ∀ {n} (xs : Vec A n) → xs ++ [] ≈ xs
  xs++[]=xs []       = []-cong
  xs++[]=xs (x ∷ xs) = SS.refl ∷-cong xs++[]=xs xs</code></pre>
</div>
<div id="problem-z-typami-zależnymi" class="slide section level1">
<h1>Problem z typami zależnymi</h1>
<p>O ile Haskell bywa czasami nieczytelny, to z typami zależnymi całkiem łatwo przesadzić:</p>
<pre><code>  now-or-never : Reflexive _∼_ →
                 ∀ {k} (x : A ⊥) →
                 ¬ ¬ ((∃ λ y → x ⇓[ other k ] y) ⊎ x ⇑[ other k ])
  now-or-never refl x = helper &lt;$&gt; excluded-middle
    where
    open RawMonad ¬¬-Monad

    not-now-is-never : (x : A ⊥) → (∄ λ y → x ≳ now y) → x ≳ never
    not-now-is-never (now x)   hyp with hyp (, now refl)
    ... | ()
    not-now-is-never (later x) hyp =
      later (♯ not-now-is-never (♭ x) (hyp ∘ Prod.map id laterˡ))

    helper : Dec (∃ λ y → x ≳ now y) → _
    helper (yes ≳now) = inj₁ $ Prod.map id ≳⇒ ≳now
    helper (no  ≵now) = inj₂ $ ≳⇒ $ not-now-is-never x ≵now</code></pre>
<p>…chociaż oczywiście pisanie takich dowodów jest świetną zabawą.</p>
</div>
<div id="parallel-haskell" class="slide section level1">
<h1>Parallel Haskell</h1>
<p>Równoległe rozwiązywanie Sudoku</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-2" title="2">    [f] <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb20-3" title="3">    grids <span class="ot">&lt;-</span> <span class="fu">fmap</span> <span class="fu">lines</span> <span class="fu">$</span> <span class="fu">readFile</span> f</a>
<a class="sourceLine" id="cb20-4" title="4">    runEval (parMap solve grids) <span class="ot">`deepseq`</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb20-5" title="5"></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="ot">parMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Eval</span> [b]</a>
<a class="sourceLine" id="cb20-7" title="7">parMap f [] <span class="fu">=</span> <span class="fu">return</span> []</a>
<a class="sourceLine" id="cb20-8" title="8">parMap f (a<span class="fu">:</span>as) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-9" title="9">   b <span class="ot">&lt;-</span> rpar (f a)</a>
<a class="sourceLine" id="cb20-10" title="10">   bs <span class="ot">&lt;-</span> parMap f as</a>
<a class="sourceLine" id="cb20-11" title="11">   <span class="fu">return</span> (b<span class="fu">:</span>bs)</a>
<a class="sourceLine" id="cb20-12" title="12"></a>
<a class="sourceLine" id="cb20-13" title="13"><span class="ot">solve ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Grid</span></a></code></pre></div>
<pre><code>$ ./sudoku3b sudoku17.1000.txt +RTS -N2 -s -RTS
  TASKS: 4 (1 bound, 3 peak workers (3 total), using -N2)
  SPARKS: 1000 (1000 converted, 0 overflowed, 0 dud, 0 GC&#39;d, 0 fizzled)

  Total   time    2.84s  (  1.49s elapsed)
  Productivity  88.9% of total user, 169.6% of total elapsed

-N8: Productivity  78.5% of total user, 569.3% of total elapsed
N16: Productivity  62.8% of total user, 833.8% of total elapsed
N32: Productivity  43.5% of total user, 1112.6% of total elapsed</code></pre>
</div>
<div id="parallel-fibonacci" class="slide section level1">
<h1>Parallel Fibonacci</h1>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="ot">cutoff ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb22-2" title="2">cutoff <span class="fu">=</span> <span class="dv">20</span></a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4">parFib n <span class="fu">|</span> n <span class="fu">&lt;</span> cutoff <span class="fu">=</span> fib n</a>
<a class="sourceLine" id="cb22-5" title="5">parFib n <span class="fu">=</span> p <span class="ot">`par`</span> q <span class="ot">`pseq`</span> (p <span class="fu">+</span> q)</a>
<a class="sourceLine" id="cb22-6" title="6">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-7" title="7">      p <span class="fu">=</span> parFib <span class="fu">$</span> n <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-8" title="8">      q <span class="fu">=</span> parFib <span class="fu">$</span> n <span class="fu">-</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb22-9" title="9"></a>
<a class="sourceLine" id="cb22-10" title="10">fib n <span class="fu">|</span> n<span class="fu">&lt;</span><span class="dv">2</span> <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb22-11" title="11">fib n <span class="fu">=</span> fib (n <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> fib (n <span class="fu">-</span> <span class="dv">2</span>)</a></code></pre></div>
<pre><code>./parfib +RTS -N60 -s -RTS
 SPARKS: 118393 (42619 converted, 0 overflowed, 0 dud,
                 11241 GC&#39;d, 64533 fizzled)

  Total   time   17.91s  (  0.33s elapsed)
  Productivity  98.5% of total user, 5291.5% of total elapsed

-N60, cutoff=15
  SPARKS: 974244 (164888 converted, 0 overflowed, 0 dud,
                  156448 GC&#39;d, 652908 fizzled)
  Total   time   13.59s  (  0.28s elapsed)
  Productivity  97.6% of total user, 4746.9% of total elapsed</code></pre>
</div>
<div id="data-parallel-haskell" class="slide section level1">
<h1>Data Parallel Haskell</h1>
<p>Dokąd chcemy dojść:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="ot">{-# LANGUAGE ParallelArrays #-}</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="ot">{-# OPTIONS_GHC -fvectorise #-}</span></a>
<a class="sourceLine" id="cb24-3" title="3"></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="kw">module</span> <span class="dt">DotP</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span></a>
<a class="sourceLine" id="cb24-6" title="6"><span class="kw">import</span> <span class="dt">Data.Array.Parallel</span></a>
<a class="sourceLine" id="cb24-7" title="7"><span class="kw">import</span> <span class="dt">Data.Array.Parallel.Prelude</span></a>
<a class="sourceLine" id="cb24-8" title="8"><span class="kw">import</span> <span class="dt">Data.Array.Parallel.Prelude.Double</span> <span class="kw">as</span> <span class="dt">D</span></a>
<a class="sourceLine" id="cb24-9" title="9"></a>
<a class="sourceLine" id="cb24-10" title="10"><span class="ot">dotp_double ::</span> [<span class="fu">:</span><span class="dt">Double</span><span class="fu">:</span>] <span class="ot">-&gt;</span> [<span class="fu">:</span><span class="dt">Double</span><span class="fu">:</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb24-11" title="11">dotp_double xs ys <span class="fu">=</span> D.sumP [<span class="fu">:</span>x <span class="fu">*</span> y <span class="fu">|</span> x <span class="ot">&lt;-</span> xs <span class="fu">|</span> y <span class="ot">&lt;-</span> ys<span class="fu">:</span>]</a></code></pre></div>
<p>Wygląda jak operacja na listach, ale działa na tablicach i “automagicznie” zrównolegla się na dowolną liczbę rdzeni/procesorów (także CUDA).</p>
<p>Po drodze czeka nas jednak trochę pracy.</p>
</div>
<div id="typy-w-haskellu" class="slide section level1">
<h1>Typy w Haskellu</h1>
<ul>
<li>typy bazowe: <code>zeroInt :: Int</code></li>
<li>typy funkcyjne: <code>plusInt :: Int -&gt; Int -&gt; Int</code></li>
<li><p>typy polimorficzne <code>id :: a -&gt; a</code></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="ot">g ::</span> <span class="kw">forall</span> b<span class="fu">.</span>b <span class="ot">-&gt;</span> b</a></code></pre></div></li>
<li><p>typy algebraiczne</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a></code></pre></div></li>
<li><p><code>Leaf</code> i <code>Node</code> są konstruktorami wartości:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" title="2">     <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb27-3" title="3">     <span class="dt">Node</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a></code></pre></div></li>
<li><p><code>Tree</code> jest <em>konstruktorem typowym</em>, czyli operacją na typach</p></li>
<li><p>NB od niedawna Haskell dopuszcza puste typy:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">data</span> <span class="dt">Zero</span></a></code></pre></div></li>
</ul>
</div>
<div id="typowanie-polimorficzne" class="slide section level1">
<h1>Typowanie polimorficzne</h1>
<ul>
<li>Generalizacja:</li>
</ul>
<p><span class="math display">\[{\Gamma \vdash e :: t, a \notin FV( \Gamma )}\over {\Gamma \vdash e :: \forall a.t}\]</span></p>
<p><!--
Jeśli $\Gamma \vdash e :: t, a \notin FV( \Gamma )$

to $\Gamma \vdash e :: \forall a.t$

  Γ ⊢ e :: t, a∉FV(Γ)
$$\Gamma \vdash e :: t$$ ,
 \(a \not\in FV(\Gamma) \) ,
to $\Gamma \vdash e :: \forall a.t$
--></p>
<p>Na przykład</p>
<p><span class="math display">\[{ { \vdash map :: (a\to b) \to [a] \to [b] } \over
   { \vdash map :: \forall b. (a\to b) \to [a] \to [b] } } \over
   { \vdash map :: \forall a. \forall b. (a\to b) \to [a] \to [b] } \]</span></p>
<p>Uwaga:</p>
<p><span class="math display">\[ f : a \to b \not \vdash map\; f :: \forall b. [a] \to [b]  \]</span></p>
<ul>
<li>Instancjacja</li>
</ul>
<p><span class="math display">\[ {\Gamma \vdash e :: \forall a.t}\over {\Gamma \vdash e :: t[a:=s]} \]</span></p>
</div>
<div id="klasy" class="slide section level1">
<h1>Klasy</h1>
<ul>
<li><p>klasy opisują własności typów</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-4" title="4">   <span class="dt">True</span>  <span class="fu">==</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb29-5" title="5">   <span class="dt">False</span> <span class="fu">==</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb29-6" title="6">   _     <span class="fu">==</span> _     <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb29-7" title="7"></a>
<a class="sourceLine" id="cb29-8" title="8"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> a <span class="kw">where</span> <span class="fu">...</span></a></code></pre></div></li>
<li><p>funkcje mogą być definiowane w kontekście klas:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="fu">elem</span><span class="ot"> ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div></li>
<li>Implementacja
<ul>
<li>instancja tłumaczona na słownik metod (coś 'a la vtable w C++)</li>
<li>kontekst (np Eq a) jest tłumaczony na ukryty parametr (słownik metod )</li>
<li>podklasa tłumaczona na funkcję</li>
</ul></li>
</ul>
</div>
<div id="operacje-na-typach" class="slide section level1">
<h1>Operacje na typach</h1>
<ul>
<li><p>Prosty przykład:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a></code></pre></div></li>
<li><p>Konstruktory typowe transformują typy</p></li>
<li><p><code>Tree</code> może zamienić np. <code>Int</code> w drzewo</p></li>
<li><p>Funkcje wyższego rzędu transformują funkcje</p></li>
<li><p>Konstruktory wyższego rzędu transformują konstruktory typów</p></li>
</ul>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">newtype</span> <span class="dt">IdentityT</span> m a <span class="fu">=</span> <span class="dt">IdentityT</span> {<span class="ot"> runIdentityT ::</span> m a }</a></code></pre></div>
</div>
<div id="klasy-konstruktorowe" class="slide section level1">
<h1>Klasy konstruktorowe</h1>
<ul>
<li><p>klasy konstruktorowe opisują własności konstruktorów typów:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="ot">  fmap ::</span> (a<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb33-3" title="3">(<span class="fu">&lt;$&gt;</span>) <span class="fu">=</span> <span class="fu">fmap</span></a>
<a class="sourceLine" id="cb33-4" title="4"></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-6" title="6">  <span class="fu">fmap</span> <span class="fu">=</span> <span class="fu">map</span></a>
<a class="sourceLine" id="cb33-7" title="7"></a>
<a class="sourceLine" id="cb33-8" title="8"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Pointed</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-9" title="9"><span class="ot">   pure ::</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb33-10" title="10"><span class="kw">instance</span> <span class="dt">Pointed</span> [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-11" title="11">   <span class="fu">pure</span> <span class="fu">=</span> (<span class="fu">:</span>[])</a>
<a class="sourceLine" id="cb33-12" title="12"></a>
<a class="sourceLine" id="cb33-13" title="13"><span class="kw">class</span> <span class="dt">Pointed</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-14" title="14"><span class="ot">  (&lt;*&gt;) ::</span> f(a<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb33-15" title="15"></a>
<a class="sourceLine" id="cb33-16" title="16"><span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-17" title="17">  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> <span class="fu">concat</span> <span class="fu">$</span> <span class="fu">flip</span> <span class="fu">map</span> fs (<span class="fu">flip</span> <span class="fu">map</span> xs)</a>
<a class="sourceLine" id="cb33-18" title="18"></a>
<a class="sourceLine" id="cb33-19" title="19"><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad&#39;</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-20" title="20"><span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a></code></pre></div></li>
</ul>
<!--

    class Pointed f => Applicative f where
      (<*>) :: f(a->b) -> f a -> f b
      (*>) :: f a -> f b -> f b
      x *> y = (flip const) <$> x <*> y
      (<*) :: f a -> f b -> f a
      x <* y = const <$> x <*> y

    liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
    liftA2 f a b = f <$> a <*> b

-->
</div>
<div id="rodzaje-kinds" class="slide section level1">
<h1>Rodzaje (kinds)</h1>
<ul>
<li><p>Operacje na wartościach są opisywane przez ich typy</p></li>
<li><p>Operacje na typach są opisywane przez ich rodzaje (kinds)</p></li>
<li><p>Typy (np. <code>Int</code>) są rodzaju <code>*</code></p></li>
<li><p>Jednoargumentowe konstruktory (np. <code>Tree</code>) są rodzaju <code>* -&gt; *</code></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="ot">{-#LANGUAGE KindSignatures, ExplicitForAll #-}</span></a>
<a class="sourceLine" id="cb34-2" title="2"></a>
<a class="sourceLine" id="cb34-3" title="3"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Pointed</span> (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-4" title="4"><span class="ot">    pure ::</span> <span class="kw">forall</span> (<span class="ot">a ::</span> <span class="fu">*</span>)<span class="fu">.</span>a <span class="ot">-&gt;</span> f a</a></code></pre></div></li>
<li><p>Występują też bardziej złożone rodzaje, np. dla transformatorów monad:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">class</span> <span class="dt">MonadTrans</span> (<span class="ot">t ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="ot">    lift ::</span> <span class="dt">Monad</span> (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">=&gt;</span> <span class="kw">forall</span> (<span class="ot">a ::</span> <span class="fu">*</span>)<span class="fu">.</span>m a <span class="ot">-&gt;</span> t m a</a></code></pre></div></li>
</ul>
<p>NB spacje są niezbędne - <code>::*-&gt;*</code> jest jednym leksemem.</p>
</div>
<div id="klasy-wieloparametrowe" class="slide section level1">
<h1>Klasy wieloparametrowe</h1>
<ul>
<li><p>Czasami potrzebujemy opisać nie tyle pojedynczy typ, co relacje między typami:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="ot">{-#LANGUAGE MultiParamTypeClasses, FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="kw">class</span> <span class="dt">Iso</span> a b <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="ot">  iso ::</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb36-4" title="4"><span class="ot">  osi ::</span> b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb36-5" title="5"></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="kw">instance</span> <span class="dt">Iso</span> a a <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-7" title="7">  iso <span class="fu">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb36-8" title="8">  osi <span class="fu">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb36-9" title="9"></a>
<a class="sourceLine" id="cb36-10" title="10"><span class="kw">instance</span> <span class="dt">Iso</span> ((a,b)<span class="ot">-&gt;</span>c) (a<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>c) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-11" title="11">  iso <span class="fu">=</span> <span class="fu">curry</span></a>
<a class="sourceLine" id="cb36-12" title="12">  osi <span class="fu">=</span> <span class="fu">uncurry</span></a>
<a class="sourceLine" id="cb36-13" title="13"></a>
<a class="sourceLine" id="cb36-14" title="14"><span class="kw">instance</span> (<span class="dt">Iso</span> a b) <span class="ot">=&gt;</span> <span class="dt">Iso</span> [a] [b] <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-15" title="15"> iso <span class="fu">=</span> <span class="fu">map</span> iso</a>
<a class="sourceLine" id="cb36-16" title="16"> osi <span class="fu">=</span> <span class="fu">map</span> osi</a></code></pre></div></li>
<li><p>Uwaga: w ostatnim przykładzie <code>iso</code> ma inny typ po lewej, inny po prawej</p></li>
<li><p>Ćwiczenie: napisz jeszcze jakieś instancje klasy <code>Iso</code></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Iso</span> a b) <span class="ot">=&gt;</span> <span class="dt">Iso</span> (f a) (f b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="kw">instance</span> <span class="dt">Iso</span> (a<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>c) (b<span class="ot">-&gt;</span>a<span class="ot">-&gt;</span>c) <span class="kw">where</span></a></code></pre></div></li>
</ul>
</div>
<div id="dygresja---flexibleinstances" class="slide section level1">
<h1>Dygresja - FlexibleInstances</h1>
<p>Haskell 2010</p>
<!--
An instance declaration introduces an instance of a class. Let class
cx => C u where { cbody } be a class declaration. The general form of
the corresponding instance declaration is: instance cx′ => C (T u1 …
uk) where { d } where k ≥ 0. The type (T u1 … uk) must take the form
of a type constructor T applied to simple type variables u1, … uk;
furthermore, T must not be a type synonym, and the ui must all be
distinct.
-->
<ul>
<li>an instance head must have the form C (T u1 … uk), where T is a type constructor defined by a data or newtype declaration and the ui are distinct type variables, and</li>
</ul>
<!--
*    each assertion in the context must have the form C' v, where v is one of the ui.
-->
<p>This prohibits instance declarations such as:</p>
<p>instance C (a,a) where … instance C (Int,a) where … instance C [[a]] where …</p>
<p><code>instance Iso a a</code> nie spełnia tych warunków, ale wiadomo o jaką relację nam chodzi :)</p>
</div>
<div id="problem-z-klasami-wieloparametrowymi" class="slide section level1">
<h1>Problem z klasami wieloparametrowymi</h1>
<p>Spróbujmy stworzyć klasę kolekcji, np.</p>
<p><code>BadCollection.hs</code></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">class</span> <span class="dt">Collection</span> c <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="ot">  insert ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb38-3" title="3"><span class="ot">  member ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb38-4" title="4"></a>
<a class="sourceLine" id="cb38-5" title="5"><span class="kw">instance</span> <span class="dt">Collection</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-6" title="6">     insert <span class="fu">=</span> (<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb38-7" title="7">     member <span class="fu">=</span> <span class="fu">elem</span></a></code></pre></div>
<pre><code>    Couldn&#39;t match type `e&#39; with `a&#39;
      `e&#39; is a rigid type variable bound by
          the type signature for member :: e -&gt; [a] -&gt; Bool
          at BadCollection.hs:7:6
      `a&#39; is a rigid type variable bound by
          the instance declaration
          at BadCollection.hs:5:22</code></pre>
<p>Dlaczego?</p>
</div>
<div id="problem-z-klasami-wieloparametrowymi-1" class="slide section level1">
<h1>Problem z klasami wieloparametrowymi</h1>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="kw">class</span> <span class="dt">Collection</span> c <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-2" title="2"><span class="ot"> insert ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb40-3" title="3"><span class="ot"> member ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p>tłumaczy się (mniej więcej) do</p>
<pre><code>data ColDic c = CD
 {
 , insert :: forall e.e -&gt; c -&gt; c
 , member :: forall e.e -&gt; c -&gt; Bool
 }</code></pre>
<p>… nie o to nam chodziło.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1"><span class="kw">instance</span> <span class="dt">Collection</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-2" title="2">   insert <span class="fu">=</span> (<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb42-3" title="3">   member <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<pre><code>-- (:) :: forall t. t -&gt; [t] -&gt; [t]
ColList :: forall a. ColDic a
ColList = \@ a -&gt; CD { insert = (:) @ a, member =</code></pre>
</div>
<div id="problem-z-klasami-wieloparametrowymi-2" class="slide section level1">
<h1>Problem z klasami wieloparametrowymi</h1>
<p><!--- `BadCollection2.hs` --> <!---
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
--></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1"><span class="kw">class</span> <span class="dt">Collection</span> c e <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-2" title="2"><span class="ot">  insert ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb44-3" title="3"><span class="ot">  member ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb44-4" title="4"></a>
<a class="sourceLine" id="cb44-5" title="5"><span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Collection</span> [a] a <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-6" title="6">  insert  <span class="fu">=</span> (<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb44-7" title="7">  member <span class="fu">=</span> <span class="fu">elem</span></a>
<a class="sourceLine" id="cb44-8" title="8"></a>
<a class="sourceLine" id="cb44-9" title="9">ins2 x y c <span class="fu">=</span> insert y (insert x c)</a>
<a class="sourceLine" id="cb44-10" title="10"><span class="co">-- ins2 :: (Collection c e, Collection c e1) =&gt; e1 -&gt; e -&gt; c -&gt; c</span></a>
<a class="sourceLine" id="cb44-11" title="11"></a>
<a class="sourceLine" id="cb44-12" title="12"><span class="ot">problem1 ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb44-13" title="13">problem1 <span class="fu">=</span> ins2 <span class="dv">1</span> <span class="dv">2</span> []</a>
<a class="sourceLine" id="cb44-14" title="14"><span class="co">-- No instances for (Collection [Int] e0, Collection [Int] e1)</span></a>
<a class="sourceLine" id="cb44-15" title="15"><span class="co">-- arising from a use of `ins2&#39;</span></a>
<a class="sourceLine" id="cb44-16" title="16"></a>
<a class="sourceLine" id="cb44-17" title="17">problem2 <span class="fu">=</span> ins2 <span class="ch">&#39;a&#39;</span> <span class="ch">&#39;b&#39;</span> []</a>
<a class="sourceLine" id="cb44-18" title="18"><span class="co">-- No instance for (Collection [a0] Char)</span></a>
<a class="sourceLine" id="cb44-19" title="19"><span class="co">--       arising from a use of `ins2&#39;</span></a>
<a class="sourceLine" id="cb44-20" title="20"></a>
<a class="sourceLine" id="cb44-21" title="21"><span class="ot">problem3 ::</span> (<span class="dt">Collection</span> c0 <span class="dt">Char</span>, <span class="dt">Collection</span> c0 <span class="dt">Bool</span>) <span class="ot">=&gt;</span> c0 <span class="ot">-&gt;</span> c0</a>
<a class="sourceLine" id="cb44-22" title="22">problem3 <span class="fu">=</span> ins2 <span class="dt">True</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb44-23" title="23"><span class="co">-- Tu problem akurat polega na tym, że to jest poprawne typowo</span></a>
<a class="sourceLine" id="cb44-24" title="24"><span class="co">-- ...a chyba nie powinno być</span></a></code></pre></div>
</div>
<div id="zależności-funkcyjne" class="slide section level1">
<h1>Zależności funkcyjne</h1>
<p>Czasami w klasach wieloparametrowych, jeden parametr wyznacza inny, np.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1"> <span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s m <span class="fu">|</span> m <span class="ot">-&gt;</span> s <span class="kw">where</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb45-2" title="2"></a>
<a class="sourceLine" id="cb45-3" title="3"> <span class="kw">class</span> <span class="dt">Collects</span> e ce <span class="fu">|</span> ce <span class="ot">-&gt;</span> e <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-4" title="4"><span class="ot">      empty  ::</span> ce</a>
<a class="sourceLine" id="cb45-5" title="5"><span class="ot">      insert ::</span> e <span class="ot">-&gt;</span> ce <span class="ot">-&gt;</span> ce</a>
<a class="sourceLine" id="cb45-6" title="6"><span class="ot">      member ::</span> e <span class="ot">-&gt;</span> ce <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p>Problem: <em>Fundeps are very, very tricky.</em> - SPJ</p>
<p>Więcej: http://research.microsoft.com/en-us/um/people/simonpj/papers/fd-chr/</p>
</div>
<div id="refleksja---czemu-nie-klasy-konstruktorowe" class="slide section level1">
<h1>Refleksja - czemu nie klasy konstruktorowe?</h1>
<p>Problem kolekcji możemy rozwiązać np. tak:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1"><span class="kw">class</span> <span class="dt">Collection</span> c <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-2" title="2"><span class="ot">  insert ::</span> e <span class="ot">-&gt;</span> c e <span class="ot">-&gt;</span> c e</a>
<a class="sourceLine" id="cb46-3" title="3"><span class="ot">  member ::</span> <span class="dt">Eq</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> c e<span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb46-4" title="4"></a>
<a class="sourceLine" id="cb46-5" title="5"><span class="kw">instance</span> <span class="dt">Collection</span> [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-6" title="6">     insert x xs <span class="fu">=</span> x<span class="fu">:</span>xs</a>
<a class="sourceLine" id="cb46-7" title="7">     member <span class="fu">=</span> <span class="fu">elem</span></a></code></pre></div>
<p>ale nie rozwiązuje to problemu np. z monadą stanu:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1"> <span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s m <span class="fu">|</span> m <span class="ot">-&gt;</span> s <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-2" title="2"><span class="ot">   get ::</span> m s</a>
<a class="sourceLine" id="cb47-3" title="3"><span class="ot">   put ::</span> s <span class="ot">-&gt;</span> m ()</a></code></pre></div>
<p>typ stanu <code>s</code> nie jest tu parametrem konstruktora <code>m</code>.</p>
</div>
<div id="fundeps-are-very-very-tricky" class="slide section level1">
<h1>Fundeps are very very tricky</h1>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" title="1"><span class="kw">class</span> <span class="dt">Mul</span> a b c <span class="fu">|</span> a b <span class="ot">-&gt;</span> c <span class="kw">where</span></a>
<a class="sourceLine" id="cb48-2" title="2"><span class="ot">  (*) ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb48-3" title="3"></a>
<a class="sourceLine" id="cb48-4" title="4"><span class="kw">newtype</span> <span class="dt">Vec</span> a <span class="fu">=</span> <span class="dt">Vec</span> [a]</a>
<a class="sourceLine" id="cb48-5" title="5"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Vec</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb48-6" title="6">  <span class="fu">fmap</span> f (<span class="dt">Vec</span> as) <span class="fu">=</span> <span class="dt">Vec</span> <span class="fu">$</span> <span class="fu">map</span> f as</a>
<a class="sourceLine" id="cb48-7" title="7"></a>
<a class="sourceLine" id="cb48-8" title="8"><span class="kw">instance</span> <span class="dt">Mul</span> a b c <span class="ot">=&gt;</span> <span class="dt">Mul</span> a (<span class="dt">Vec</span> b) (<span class="dt">Vec</span> c) <span class="kw">where</span></a>
<a class="sourceLine" id="cb48-9" title="9">  a <span class="fu">*</span> b <span class="fu">=</span> <span class="fu">fmap</span> (a<span class="fu">*</span>) b</a>
<a class="sourceLine" id="cb48-10" title="10"></a>
<a class="sourceLine" id="cb48-11" title="11">f t x y <span class="fu">=</span> <span class="kw">if</span> t <span class="kw">then</span>  x <span class="fu">*</span> (<span class="dt">Vec</span> [y]) <span class="kw">else</span> y</a></code></pre></div>
<p>Jakiego typu jest f? Niech x::a, y::b.</p>
<p>Wtedy typem wyniku jest b i musimy mieć instancję <code>Mul a (Vec b) b</code></p>
<p>Z kolei <code>a b -&gt; c</code> implikuje, że <code>b = Vec c</code> dla pewnego c, czyli szukamy instancji</p>
<pre><code>Mul a (Vec (Vec c)) (Vec c)</code></pre>
<p>zastosowanie reguły <code>Mul a b c =&gt; Mul a (Vec b) (Vec c)</code> doprowadzi nas do <code>Mul a (Vec c) c</code>.</p>
<p>…i tak w kółko.</p>
</div>
<div id="spróbujmy" class="slide section level1">
<h1>Spróbujmy</h1>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" title="1">Mul1.hs<span class="fu">:</span><span class="dv">16</span><span class="fu">:</span><span class="dv">21</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb50-2" title="2">    <span class="dt">Context</span> reduction stack overflow; size <span class="fu">=</span> <span class="dv">21</span></a>
<a class="sourceLine" id="cb50-3" title="3">    <span class="dt">Use</span> <span class="fu">-</span>fcontext<span class="fu">-</span>stack<span class="fu">=</span><span class="dt">N</span> to increase stack size to <span class="dt">N</span></a>
<a class="sourceLine" id="cb50-4" title="4"><span class="ot">      co ::</span> c18 <span class="fu">~</span> <span class="dt">Vec</span> c19</a>
<a class="sourceLine" id="cb50-5" title="5">      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 c17 c18</a>
<a class="sourceLine" id="cb50-6" title="6">      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 c16 c17</a>
<a class="sourceLine" id="cb50-7" title="7">      <span class="fu">...</span></a>
<a class="sourceLine" id="cb50-8" title="8">      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 c1 c2</a>
<a class="sourceLine" id="cb50-9" title="9">      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 c c1</a>
<a class="sourceLine" id="cb50-10" title="10">      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 c0 c</a>
<a class="sourceLine" id="cb50-11" title="11">      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 (<span class="dt">Vec</span> c0) c0</a>
<a class="sourceLine" id="cb50-12" title="12">    <span class="dt">When</span> using functional dependencies to combine</a>
<a class="sourceLine" id="cb50-13" title="13">      <span class="dt">Mul</span> a (<span class="dt">Vec</span> b) (<span class="dt">Vec</span> c),</a>
<a class="sourceLine" id="cb50-14" title="14">        arising from the dependency <span class="ot">`a b -&gt; c&#39;</span></a>
<a class="sourceLine" id="cb50-15" title="15"><span class="ot">        in the instance declaration at 3/Mul1.hs:13:10</span></a>
<a class="sourceLine" id="cb50-16" title="16"><span class="ot">      Mul a0 (Vec c18) c18,</span></a>
<a class="sourceLine" id="cb50-17" title="17"><span class="ot">        arising from a use of `</span>mul&#39; at <span class="dv">3</span><span class="fu">/</span>Mul1.hs<span class="fu">:</span><span class="dv">16</span><span class="fu">:</span><span class="dv">21</span><span class="fu">-</span><span class="dv">23</span></a>
<a class="sourceLine" id="cb50-18" title="18">    <span class="dt">In</span> the expression<span class="fu">:</span> mul x (<span class="dt">Vec</span> [y])</a>
<a class="sourceLine" id="cb50-19" title="19">    <span class="dt">In</span> the expression<span class="fu">:</span> <span class="kw">if</span> b <span class="kw">then</span> mul x (<span class="dt">Vec</span> [y]) <span class="kw">else</span> y</a></code></pre></div>
<p>(musimy użyć UndecidableInstances, żeby GHC w ogóle spróbowało - ten przykład pokazuje co jest ‘Undecidable’).</p>
</div>
<div id="rodziny-typów" class="slide section level1">
<h1>Rodziny typów</h1>
<p>Rodziny to funkcje na typach - jak na pierwszym wykładzie</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" title="1"><span class="ot">{-# TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb51-2" title="2"></a>
<a class="sourceLine" id="cb51-3" title="3"><span class="kw">data</span> <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb51-4" title="4"><span class="kw">data</span> <span class="dt">Suc</span> n <span class="fu">=</span> <span class="dt">Suc</span> n</a>
<a class="sourceLine" id="cb51-5" title="5"></a>
<a class="sourceLine" id="cb51-6" title="6"><span class="kw">type</span> <span class="kw">family</span> m <span class="fu">:+</span> n</a>
<a class="sourceLine" id="cb51-7" title="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Zero</span> <span class="fu">:+</span> n <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb51-8" title="8"><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Suc</span> m) <span class="fu">:+</span> n <span class="fu">=</span> <span class="dt">Suc</span>(m<span class="fu">:+</span>n)</a>
<a class="sourceLine" id="cb51-9" title="9"></a>
<a class="sourceLine" id="cb51-10" title="10"><span class="ot">vhead ::</span> <span class="dt">Vec</span> (<span class="dt">Suc</span> n) a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb51-11" title="11"><span class="ot">vappend ::</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m<span class="fu">:+</span>n) a</a></code></pre></div>
<p>Trochę dalej powiemy sobie o nich bardziej systematycznie.</p>
</div>
</body>
</html>
